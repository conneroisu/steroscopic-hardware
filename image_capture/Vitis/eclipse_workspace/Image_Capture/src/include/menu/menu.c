#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h> // For sleep function

#define MENU_FONT_WIDTH 8
#define MENU_FONT_HEIGHT 8
#define IMAGE_WIDTH 480
#define IMAGE_HEIGHT 640

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef u16 t_image_type[IMAGE_HEIGHT][IMAGE_WIDTH];

/*
 * Complete 8x8 font table for the first 128 ASCII characters.
 * (Data derived from the public domain font8x8_basic)
 */
static const u8 font8x8_basic[128][8] = {
    [0x00] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x01] = {0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E},
    [0x02] = {0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E},
    [0x03] = {0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00},
    [0x04] = {0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00},
    [0x05] = {0x00, 0x18, 0x3C, 0x7E, 0x3C, 0x18, 0x00, 0x00},
    [0x06] = {0xFF, 0xE7, 0xC3, 0x81, 0xC3, 0xE7, 0xFF, 0x00},
    [0x07] = {0x00, 0x66, 0xFF, 0xFF, 0xFF, 0x6E, 0x3C, 0x00},
    [0x08] = {0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00},
    [0x09] = {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x0A] = {0x18, 0x3C, 0x7E, 0xFF, 0x7E, 0x3C, 0x18, 0x00},
    [0x0B] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x0C] = {0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x18, 0x00},
    [0x0D] = {0xFF, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x0E] = {0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x0F] = {0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x10] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x11] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x12] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x14] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x15] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x17] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x18] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x19] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1A] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1B] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1C] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1D] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1E] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1F] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // Printable characters (0x20 to 0x7E)
    [0x20] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space
    [0x21] = {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
    [0x22] = {0x6C, 0x6C, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    [0x23] = {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00}, // #
    [0x24] = {0x18, 0x3E, 0x58, 0x3C, 0x1A, 0x7C, 0x18, 0x00}, // $
    [0x25] = {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00}, // %
    [0x26] = {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00}, // &
    [0x27] = {0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    [0x28] = {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, // (
    [0x29] = {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, // )
    [0x2A] = {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // *
    [0x2B] = {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}, // +
    [0x2C] = {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00}, // ,
    [0x2D] = {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, // -
    [0x2E] = {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00}, // .
    [0x2F] = {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}, // /
    [0x30] = {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00}, // 0
    [0x31] = {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
    [0x32] = {0x7C, 0xC6, 0x0E, 0x1C, 0x70, 0xC6, 0xFE, 0x00}, // 2
    [0x33] = {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00}, // 3
    [0x34] = {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00}, // 4
    [0x35] = {0xFE, 0xC0, 0xF8, 0x0C, 0x06, 0xC6, 0x7C, 0x00}, // 5
    [0x36] = {0x3C, 0x60, 0xC0, 0xF8, 0xC6, 0xC6, 0x7C, 0x00}, // 6
    [0x37] = {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    [0x38] = {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00}, // 8
    [0x39] = {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00}, // 9
    [0x3A] = {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
    [0x3B] = {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00}, // ;
    [0x3C] = {0x0E, 0x1C, 0x38, 0x70, 0x38, 0x1C, 0x0E, 0x00}, // <
    [0x3D] = {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}, // =
    [0x3E] = {0x70, 0x38, 0x1C, 0x0E, 0x1C, 0x38, 0x70, 0x00}, // >
    [0x3F] = {0x7C, 0xC6, 0x0E, 0x1C, 0x18, 0x00, 0x18, 0x00}, // ?
    [0x40] = {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x7C, 0x00}, // @
    [0x41] = {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // A
    [0x42] = {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, // B
    [0x43] = {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00}, // C
    [0x44] = {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, // D
    [0x45] = {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00}, // E
    [0x46] = {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00}, // F
    [0x47] = {0x3C, 0x66, 0xC0, 0xCE, 0xC6, 0x66, 0x3A, 0x00}, // G
    [0x48] = {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // H
    [0x49] = {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // I
    [0x4A] = {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00}, // J
    [0x4B] = {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00}, // K
    [0x4C] = {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00}, // L
    [0x4D] = {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00}, // M
    [0x4E] = {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00}, // N
    [0x4F] = {0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // O
    [0x50] = {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, // P
    [0x51] = {0x78, 0xCC, 0xCC, 0xCC, 0xD8, 0x70, 0xDC, 0x00}, // Q
    [0x52] = {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00}, // R
    [0x53] = {0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00}, // S
    [0x54] = {0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x3C, 0x00}, // T
    [0x55] = {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // U
    [0x56] = {0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00}, // V
    [0x57] = {0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00}, // W
    [0x58] = {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00}, // X
    [0x59] = {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00}, // Y
    [0x5A] = {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00}, // Z
    [0x5B] = {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}, // [
    [0x5C] = {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00}, // backslash
    [0x5D] = {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}, // ]
    [0x5E] = {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00}, // ^
    [0x5F] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // _
    [0x60] = {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00}, // `
    [0x61] = {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00}, // a
    [0x62] = {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00}, // b
    [0x63] = {0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00}, // c
    [0x64] = {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // d
    [0x65] = {0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00}, // e
    [0x66] = {0x38, 0x6C, 0x60, 0xF8, 0x60, 0x60, 0xF0, 0x00}, // f
    [0x67] = {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8}, // g
    [0x68] = {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00}, // h
    [0x69] = {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
    [0x6A] = {0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78}, // j
    [0x6B] = {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00}, // k
    [0x6C] = {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
    [0x6D] = {0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xC6, 0x00}, // m
    [0x6E] = {0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
    [0x6F] = {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // o
    [0x70] = {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0}, // p
    [0x71] = {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E}, // q
    [0x72] = {0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00}, // r
    [0x73] = {0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00}, // s
    [0x74] = {0x30, 0x30, 0xFC, 0x30, 0x30, 0x36, 0x1C, 0x00}, // t
    [0x75] = {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // u
    [0x76] = {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // v
    [0x77] = {0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00}, // w
    [0x78] = {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00}, // x
    [0x79] = {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0xFC}, // y
    [0x7A] = {0x00, 0x00, 0xFE, 0x4C, 0x18, 0x32, 0xFE, 0x00}, // z
    [0x7B] = {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00}, // {
    [0x7C] = {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // |
    [0x7D] = {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00}, // }
    [0x7E] = {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ~
    [0x7F] = {0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00}  // DEL
};

/*
 * Draw a single character at (x, y) using the given 16-bit color.
 */
void draw_char(t_image_type fb, int x, int y, char c, u16 color) {
  if ((unsigned char)c > 127) {
    return;
  }
  for (int row = 0; row < MENU_FONT_HEIGHT; row++) {
    u8 row_bits = font8x8_basic[(unsigned char)c][row];
    for (int col = 0; col < MENU_FONT_WIDTH; col++) {
      if (row_bits & (1 << (7 - col))) {
        int px = x + col;
        int py = y + row;
        if (px >= 0 && px < IMAGE_WIDTH && py >= 0 && py < IMAGE_HEIGHT) {
          fb[py][px] = color;
        }
      }
    }
  }
}

/**
 * @brief Fill a rectangle in the given framebuffer.
 *
 * @param fb is the framebuffer to draw on.
 * @param x is the x-coordinate of the upper-left corner.
 * @param y is the y-coordinate of the upper-left corner.
 * @param width is the width of the rectangle.
 * @param height is the height of the rectangle.
 * @param color is the color to fill the rectangle.
 */
void fill_rect(u16 fb[IMAGE_HEIGHT][IMAGE_WIDTH],
               int x,       //
               int y,       //
               int width,   //
               int height,  //
               u16 color) { //
  for (int j = y; j < y + height; j++) {
    for (int i = x; i < x + width; i++) {
      if (i >= 0 && i < IMAGE_WIDTH && j >= 0 && j < IMAGE_HEIGHT) {
        fb[j][i] = color;
      }
    }
  }
}

/**
 * @brief Draw a string at the given coordinates using the given color.
 *
 * @param fb the framebuffer to draw on.
 * @param str the string to draw.
 * @param x the x-coordinate of the upper-left corner.
 * @param y the y-coordinate of the upper-left corner.
 * @param color the color to draw the string.
 */
void draw_string(u16 fb[IMAGE_HEIGHT][IMAGE_WIDTH],
                 char *str,   //
                 int x,       //
                 int y,       //
                 u16 color) { //
  for (int i = 0; i < strlen(str); i++) {
    draw_char(fb, x + i * MENU_FONT_WIDTH, y, str[i], color);
  }
}

/**
 * @brief Draw a rounded rectangle border (outline only) into the given
 * framebuffer.
 *
 * @param fb is the framebuffer to draw on.
 * @param rect_x is the x-coordinate of the upper-left corner.
 * @param rect_y is the y-coordinate of the upper-left corner.
 * @param rect_width is the width of the rectangle.
 * @param rect_height is the height of the rectangle.
 * @param radius is the radius of the rounded corners.
 * @param color is the color of the rectangle.
 */
void draw_rounded_rect(u16 fb[IMAGE_HEIGHT][IMAGE_WIDTH], //
                       int rect_x,                        //
                       int rect_y,                        //
                       int rect_width,                    //
                       int rect_height,                   //
                       int radius,                        //
                       u16 color) {
#define SET_PIXEL(x, y)                                                        \
  do {                                                                         \
    if ((x) >= 0 && (x) < IMAGE_WIDTH && (y) >= 0 && (y) < IMAGE_HEIGHT) {     \
      fb[(y)][(x)] = (color);                                                  \
    }                                                                          \
  } while (0)

  // Draw horizontal lines (top and bottom) excluding rounded corners.
  for (int x = rect_x + radius; x < rect_x + rect_width - radius; x++) {
    SET_PIXEL(x, rect_y);                   // Top edge
    SET_PIXEL(x, rect_y + rect_height - 1); // Bottom edge
  }
  // Draw vertical lines (left and right) excluding rounded corners.
  for (int y = rect_y + radius; y < rect_y + rect_height - radius; y++) {
    SET_PIXEL(rect_x, y);                  // Left edge
    SET_PIXEL(rect_x + rect_width - 1, y); // Right edge
  }

  // Midpoint circle algorithm for the corner arcs.
  int r = radius;
  int x = 0;
  int y = r;
  int d = 1 - r;
  while (x <= y) {
    // Top-left corner (arc from 180° to 270°):
    SET_PIXEL(rect_x + r - x, rect_y + r - y);
    SET_PIXEL(rect_x + r - y, rect_y + r - x);
    // Top-right corner (arc from 270° to 360°):
    SET_PIXEL(rect_x + rect_width - r - 1 + x, rect_y + r - y);
    SET_PIXEL(rect_x + rect_width - r - 1 + y, rect_y + r - x);
    // Bottom-left corner (arc from 90° to 180°):
    SET_PIXEL(rect_x + r - x, rect_y + rect_height - r - 1 + y);
    SET_PIXEL(rect_x + r - y, rect_y + rect_height - r - 1 + x);
    // Bottom-right corner (arc from 0° to 90°):
    SET_PIXEL(rect_x + rect_width - r - 1 + x,
              rect_y + rect_height - r - 1 + y);
    SET_PIXEL(rect_x + rect_width - r - 1 + y,
              rect_y + rect_height - r - 1 + x);
    x++;
    if (d < 0) {
      d += 4 * x + 2;
    } else {
      y--;
      d += 4 * (x - y) + 2;
    }
  }
#undef SET_PIXEL
}

/**
 * @brief Draw a filled rounded rectangle into the given framebuffer.
 *
 * @param fb is the framebuffer to draw on.
 * @param rect_x is the x-coordinate of the upper-left corner.
 * @param rect_y is the y-coordinate of the upper-left corner.
 * @param rect_width is the width of the rectangle.
 * @param rect_height is the height of the rectangle.
 * @param radius is the radius of the rounded corners.
 * @param color is the color of the rectangle.
 */
void draw_rounded_filled_rect(u16 fb[IMAGE_HEIGHT][IMAGE_WIDTH], int rect_x,
                              int rect_y, int rect_width, int rect_height,
                              int radius, u16 color) {
// Helper macro to set a pixel at (x,y) with bounds checking
#define SET_PIXEL(x, y)                                                        \
  do {                                                                         \
    if ((x) >= 0 && (x) < IMAGE_WIDTH && (y) >= 0 && (y) < IMAGE_HEIGHT) {     \
      fb[(y)][(x)] = (color);                                                  \
    }                                                                          \
  } while (0)

  // Fill the center rectangle (excluding corners)
  for (int y = rect_y + radius; y < rect_y + rect_height - radius; y++) {
    for (int x = rect_x; x < rect_x + rect_width; x++) {
      SET_PIXEL(x, y);
    }
  }

  // Fill the top and bottom rectangles (excluding corners)
  for (int y = rect_y; y < rect_y + radius; y++) {
    for (int x = rect_x + radius; x < rect_x + rect_width - radius; x++) {
      SET_PIXEL(x, y);                                       // Top part
      SET_PIXEL(x, rect_y + rect_height - 1 - (y - rect_y)); // Bottom part
    }
  }

  // Draw the four corner quadrants using a variation of the midpoint circle
  // algorithm
  for (int corner = 0; corner < 4; corner++) {
    // Determine the center of the circle for each corner
    int center_x, center_y;

    switch (corner) {
    case 0: // Top-left
      center_x = rect_x + radius;
      center_y = rect_y + radius;
      break;
    case 1: // Top-right
      center_x = rect_x + rect_width - radius - 1;
      center_y = rect_y + radius;
      break;
    case 2: // Bottom-left
      center_x = rect_x + radius;
      center_y = rect_y + rect_height - radius - 1;
      break;
    case 3: // Bottom-right
      center_x = rect_x + rect_width - radius - 1;
      center_y = rect_y + rect_height - radius - 1;
      break;
    }

    // Draw filled quarter circles for each corner
    for (int y = 0; y <= radius; y++) {
      for (int x = 0; x <= radius; x++) {
        // Check if the point is inside the circle
        if (x * x + y * y <= radius * radius) {
          switch (corner) {
          case 0: // Top-left
            SET_PIXEL(center_x - x, center_y - y);
            break;
          case 1: // Top-right
            SET_PIXEL(center_x + x, center_y - y);
            break;
          case 2: // Bottom-left
            SET_PIXEL(center_x - x, center_y + y);
            break;
          case 3: // Bottom-right
            SET_PIXEL(center_x + x, center_y + y);
            break;
          }
        }
      }
    }
  }

#undef SET_PIXEL
}

/**
 * @brief Draw a percentage bar at the given coordinates using the given color.
 *
 * @param fb is the framebuffer to draw on.
 * @param x is the x-coordinate of the upper-left corner.
 * @param y is the y-coordinate of the upper-left corner.
 * @param width is the width of the bar.
 * @param height is the height of the bar.
 * @param percent is the percentage of the bar to fill.
 * @param color is the color of the bar.
 */
void draw_bar(t_image_type fb,
              int x,       //
              int y,       //
              int width,   //
              int height,  //
              int percent, //
              u16 color) { //
  if (percent > 100) {
    percent = 100;
  }
  if (percent < 5) {
    percent = 5;
  }
  // Calculate the width of the filled portion based on percentage
  int fill_width = (width * percent) / 100;

  draw_rounded_rect(fb, x - 5, y - 5, width + 10, height + 10, 10, color);
  /*fill_rect(fb, x, y, fill_width, height, color);*/
  draw_rounded_filled_rect(fb, x, y, fill_width, height, 10, color);
}

/**
 * @brief Write the framebuffer to a PPM file.
 *
 * @param fb is the framebuffer to write.
 * @param filename is the name of the file to write to.
 */
void write_ppm(t_image_type fb, const char *filename) {
  FILE *f = fopen(filename, "wb");
  if (!f) {
    perror("Error opening file for writing");
    return;
  }

  // Write PPM header (P6 format, which is the binary format)
  fprintf(f, "P6\n%d %d\n255\n", IMAGE_WIDTH, IMAGE_HEIGHT);

  // Write pixel data
  for (int y = 0; y < IMAGE_HEIGHT; y++) {
    for (int x = 0; x < IMAGE_WIDTH; x++) {
      // Convert 16-bit color (RGB565) to 24-bit RGB
      u16 color = fb[y][x];
      unsigned char r = ((color >> 11) & 0x1F)
                        << 3; // Extract 5 bits of red and shift to 8 bits
      unsigned char g = ((color >> 5) & 0x3F)
                        << 2; // Extract 6 bits of green and shift to 8 bits
      unsigned char b = (color & 0x1F)
                        << 3; // Extract 5 bits of blue and shift to 8 bits

      // Write the RGB bytes
      fputc(r, f);
      fputc(g, f);
      fputc(b, f);
    }
  }

  fclose(f);
}

//int main() {
//  // Create and initialize the framebuffer
//  t_image_type image;
//  memset(image, 0, sizeof(image)); // Start with a black image
//
//  printf("Starting image generation...\n");
//
//  char filename[50];
//  // Demo: Draw a progress bar and some text that updates
//  for (int i = 0; i <= 100; i++) {
//    // Create a constant output filename
//    sprintf(filename, "output_%03d.ppm", i);
//    printf("Progress: %d%%\n", i);
//    // Clear the image first (fill with black)
//    fill_rect(image, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT, 0x0000);
//
//    // Set colors (RGB565 format)
//    u16 bar_color = 0x07E0;    // Green
//    u16 text_color = 0xFFFF;   // White
//    u16 border_color = 0xF800; // Red
//
//    // Draw some demo elements
//    draw_bar(image, 55, 205, IMAGE_WIDTH - 110, 40, i, bar_color);
//
//    // Create a status text
//    char status[50];
//    snprintf(status, sizeof(status), "Progress: %d%%", i);
//    draw_string(image, status, 50, 180, text_color);
//
//    // Add timestamp
//    time_t now = time(NULL);
//    char time_str[50];
//    strftime(time_str, sizeof(time_str), "Time: %H:%M:%S", localtime(&now));
//    draw_string(image, time_str, 50, 160, text_color);
//
//    // Write the current state to a PPM file
//    write_ppm(image, filename);
//
//    // Sleep briefly to allow external viewers to refresh
//    printf("wait");
//    /*sleep(1); // 100ms*/
//    printf("done");
//
//    // Print update to console
//    printf("\rFrame %d/100 - Progress: %d%%", i, i);
//  }
//
//  printf("\nImage generation complete! Final output saved to %s\n", ".");
//  return 0;
//}
